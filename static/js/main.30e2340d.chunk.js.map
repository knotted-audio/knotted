{"version":3,"sources":["components/Waveform.js","actions/loop.js","actions/grid.js","components/LoopPanel.js","components/GridPanel.js","App.js","reducers/loopReducer.js","reducers/gridReducer.js","reducers/rootReducer.js","middlewares/audioScheduler.js","serviceWorker.js","index.js","store.js"],"names":["Waveform","props","buffer","width","height","zoom","color","onDone","pixelRatio","window","devicePixelRatio","canvas","useRef","useLayoutEffect","context","current","getContext","w","middle","channelData","getChannelData","step","Math","ceil","length","fillStyle","draw","dw","floor","dh","style","ref","data","ctx","i","min","max","j","datum","fillRect","memo","prevProps","nextProps","id","createLoop","type","payload","randomColor","uuidv4","TOGGLE_PLAY","Loop","index","active","tempo","setActiveLoopA","beatDuration","lengthInBeats","round","duration","useDrag","item","opacity","drag","className","paddingTop","onClick","connect","state","loops","loop","activeLoop","grid","dispatch","createLoopA","loopId","setActiveLoop","map","l","key","GridLoopMarker","soft","numMarkers","backgroundColor","Grid","beat","loopTriggers","barBeat","loopTails","setGridElemA","addLoopInstanceA","drop","useDrop","accept","instanceId","activeLoops","g","originLoop","find","range","flat","filter","start","end","val","domElem","setGridElem","addLoopInstance","beats","beatsPerBar","playing","metronome","gain","inputDeviceList","activeInputDevice","togglePlayA","toggleMetronomeA","setTempoA","setTempo","setGainA","setGain","setInputDevicesA","devices","setInputDevices","setMediaStreamA","stream","setMediaStream","mediaStream","useEffect","navigator","mediaDevices","getUserMedia","audio","deviceId","then","enumerateDevices","res","isClient","getSize","useCallback","innerWidth","undefined","innerHeight","useState","windowSize","setWindowSize","handleResize","addEventListener","removeEventListener","useWindowSize","gridWidth","deviceOpts","reduce","acc","dev","kind","label","cls","theme","onChange","options","DndProvider","backend","Backend","activeBeat","initialState","gridElems","quantizationBeats","Array","keys","combineReducers","action","gridItem","push","console","log","audioScheduler","store","next","nextNoteTime","nextBeat","nextGridChangeTime","nextGridBeat","frame","audioCtx","AudioContext","getState","secondsPerBeat","cTime","currentTime","prevBeat","classList","remove","add","forEach","source","createBufferSource","gainNode","createGain","setValueAtTime","destination","triggerLoopsAtBeat","loopStart","loopEnd","recorder","MediaRecorder","secondsUntilEnd","Promise","resolve","ondataavailable","evt","stop","d","arrayBuffer","r","err","decodeAudioData","durOffset","sampleRate","outputAudioBuffer","createBuffer","outB","inB","t","recordInputStream","b","time","osc","createOscillator","frequency","value","triggerMetronome","requestAnimationFrame","elem","cancelAnimationFrame","Boolean","location","hostname","match","ReactDOM","render","StrictMode","createStore","rootReducer","applyMiddleware","configureStore","document","getElementById","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"4RAEMA,EAAW,WAAiB,IAAhBC,EAAe,uDAAP,GAAO,EAS3BA,EAPFC,cAF6B,MAEpB,KAFoB,IAS3BD,EANFE,aAH6B,MAGrB,IAHqB,IAS3BF,EALFG,cAJ6B,MAIpB,IAJoB,IAS3BH,EAJFI,YAL6B,MAKtB,EALsB,IAS3BJ,EAHFK,aAN6B,MAMrB,QANqB,IAS3BL,EAFFM,cAP6B,MAOpB,KAPoB,IAS3BN,EADFO,kBAR6B,MAQhBC,OAAOC,iBARS,EAWzBC,EAASC,iBAAO,MAEtBC,2BAAgB,WACd,IAAMC,EAAUH,EAAOI,QAAQC,WAAW,MAEtCC,EAAId,EAAQE,EACZa,EAASd,EAAS,EAElBe,EAAcjB,EAAOkB,eAAe,GACpCC,EAAOC,KAAKC,KAAKJ,EAAYK,OAASP,GAE1CH,EAAQW,UAAYnB,EACpBoB,EAAKvB,EAAOkB,EAAMH,EAAQC,EAAaL,GAEnCP,GACFA,OAIJ,IAAMoB,EAAKL,KAAKM,MAAMpB,EAAaL,EAAQE,GACrCwB,EAAKP,KAAKM,MAAMpB,EAAaJ,GAC7B0B,EAAQ,CAAE3B,MAAOA,EAAQE,EAAMD,UACrC,OAAO,4BAAQ2B,IAAKpB,EAAQR,MAAOwB,EAAIvB,OAAQyB,EAAIC,MAAOA,KAG5D,SAASJ,EAAKvB,EAAOkB,EAAMH,EAAQc,EAAMC,GACvC,IAAK,IAAIC,EAAI,EAAGA,EAAI/B,EAAO+B,GAAK,EAI9B,IAHA,IAAIC,EAAM,EACNC,GAAO,EAEFC,EAAI,EAAGA,EAAIhB,EAAMgB,GAAK,EAAG,CAChC,IAAIC,EAAQN,EAAKE,EAAIb,EAAOgB,GAExBC,EAAQH,EACVA,EAAMG,EACGA,EAAQF,IACjBA,EAAME,GAGRL,EAAIM,SAASL,GAAI,EAAIC,GAAOjB,EAAQ,EAAGI,KAAKc,IAAI,GAAIA,EAAMD,GAAOjB,KAMxDsB,sBACb,SAACvC,GAAD,OAAW,kBAAC,EAAaA,MACzB,SAACwC,EAAWC,GAAZ,OAEID,EAAUE,KAAOD,EAAUC,IAC3BF,EAAUtC,QAAUuC,EAAUvC,OAC9BsC,EAAUrC,SAAWsC,EAAUtC,QAC/BqC,EAAUnC,QAAUoC,EAAUpC,S,yBC7DvBsC,EAAa,SAAC1C,GAAD,MAAa,CACrC2C,KAHyB,oBAIzBC,QAAS,CACP5C,SACAI,MAAOyC,MACPJ,GAAIK,iBCPKC,EAAc,oBCgC3B,SAASC,EAAT,GAWI,IAVFP,EAUC,EAVDA,GACAQ,EASC,EATDA,MAEAC,GAOC,EARD5B,OAQC,EAPD4B,QACA9C,EAMC,EANDA,MACAJ,EAKC,EALDA,OACAC,EAIC,EAJDA,MACAC,EAGC,EAHDA,OACAiD,EAEC,EAFDA,MACAC,EACC,EADDA,eAEMC,EAAe,GAAOF,EACtBG,EAAgBlC,KAAKmC,MAAMvD,EAAOwD,SAAWH,GAFlD,EAK2BI,YAAQ,CAClCC,KAAM,CAAEjB,KAAIE,KAAM,UANnB,mBAKQgB,EALR,KAKQA,QAAWC,EALnB,KASD,OACE,yBACE/B,IAAK+B,EACLC,UAAS,eAAUX,EAAS,SAAW,IACvCtB,MAAO,CAAE+B,UAASzD,SAAQD,QAAO6D,WAAY,IAC7CC,QAAS,kBAAMX,EAAeX,KAE9B,kBAAC,EAAD,CACEA,GAAIA,EACJxC,MAAOA,EACPC,OAAQA,EAAS,GACjBE,MAAOA,EACPJ,OAAQA,IAEV,qCAAWiD,EAAX,IAAmB,KAAnB,IAA0BK,EAA1B,WA8BN,IAUeU,eAVS,SAACC,GAAD,MAAY,CAClCC,MAAOD,EAAME,KAAKD,MAClBE,WAAYH,EAAMI,KAAKD,WACvBjB,MAAOc,EAAMI,KAAKlB,UAEO,SAACmB,GAAD,MAAe,CACxCC,YAAa,SAACvE,GAAD,OAAYsE,EAAS5B,EAAW1C,KAC7CoD,eAAgB,SAACoB,GAAD,OAAYF,EDnFD,SAACE,GAAD,MAAa,CACxC7B,KAjB6B,wBAkB7BC,QAAS,CAAE4B,WCiF0BC,CAAcD,QAGtCR,EAnCf,YAAsF,IAAjEE,EAAgE,EAAhEA,MAAOjE,EAAyD,EAAzDA,MAAOkD,EAAkD,EAAlDA,MAAOiB,EAA2C,EAA3CA,WAAyBhB,GAAkB,EAA/BmB,YAA+B,EAAlBnB,gBAOjE,OACE,yBAAKS,UAAU,YAAYjC,MAAO,CAAE3B,UACjCiE,EAAMQ,KAAI,SAACC,EAAG1B,GAAJ,OACT,kBAACD,EAAD,eACE4B,IAAKD,EAAElC,GACPQ,MAAOA,EACPG,eAAgBA,EAChBF,OAAQkB,IAAeO,EAAElC,IACrBkC,EALN,CAMExB,MAAOA,EACPlD,MAAOA,EAAQ,GACfC,OAjBO,a,eCpEjB,SAAS2E,EAAT,GAAyD,EAA/BpC,GAAgC,IAA5BrC,EAA2B,EAA3BA,MAAO0E,EAAoB,EAApBA,KAAMC,EAAc,EAAdA,WACnCpB,EAAUmB,EAAO,GAAM,EAC7B,OACE,yBACEjB,UAAS,yBAAoBkB,EAAa,EAAI,OAAS,IACvDnD,MAAO,CAAEoD,gBAAiB5E,EAAOuD,aAKvC,SAASsB,EAAT,GASI,IARFC,EAQC,EARDA,KAEAC,GAMC,EAPDC,QAOC,EANDD,cACAE,EAKC,EALDA,UAEAC,GAGC,EAJDlB,WAIC,EAHDkB,cACAC,EAEC,EAFDA,iBACAxB,EACC,EADDA,QAIMyB,EAAOC,YAAQ,CACnBC,OAAQ,CAAC,QACTF,KAAM,SAAC9B,GAAD,OAAU6B,EAAiBL,EAAMxB,EAAKjB,OAC3C,GAEGsC,EAAaI,EAAa7D,OAAS+D,EAAU/D,OAInD,OACE,yBACEO,IAAK,SAACA,GACJyD,EAAaJ,EAAMrD,GACnB2D,EAAK3D,IAEPgC,UAAU,OACVE,QAASA,GAERoB,EAAaT,KAAI,SAACC,GAAD,OAChB,kBAACE,EAAD,eAAgBD,IAAKD,EAAEgB,YAAgBhB,EAAvC,CAA0CI,WAAYA,QAEvDM,EAAUX,KAAI,SAACC,GAAD,OACb,kBAACE,EAAD,eAAgBD,IAAKD,EAAEgB,YAAgBhB,EAAvC,CAA0CG,MAAM,EAAMC,WAAYA,SA8B1E,IAoDef,eAlDS,SAACC,GACvB,IAAMd,EAAQc,EAAMI,KAAKlB,MAEnByC,EAAc3B,EAAMI,KAAKA,KAC5BK,KAAI,SAACmB,GAAD,OACHA,EAAEV,aAAaT,KAAI,YAAyB,IAAtBjC,EAAqB,EAArBA,GAAIkD,EAAiB,EAAjBA,WAClBG,EAAa7B,EAAME,KAAKD,MAAM6B,MAAK,SAACpB,GAAD,OAAOA,EAAElC,KAAOA,KACnDY,EAAe,GAAOF,EACtBG,EAAgBlC,KAAKmC,MAAMuC,EAAW9F,OAAOwD,SAAWH,GAExD2C,EAAQ,CACZH,EAAEX,MACDW,EAAEX,KAAO5B,EAAgB,GAAKW,EAAMI,KAAKA,KAAK/C,QAGjD,OAAO,aACL0E,QACAL,cACGG,SAIRG,OAEG5B,EAAOJ,EAAMI,KAAKA,KAAKK,KAAI,SAACmB,GAChC,IAAMV,EAAeS,EAAYM,QAAO,SAACvB,GAAD,OAAOA,EAAEqB,MAAM,KAAOH,EAAEX,QAC1DG,EAAYO,EAAYM,QAAO,SAACvB,GAAD,OA5BxBwB,EA6BHxB,EAAEqB,MAAM,GAAK,EA7BHI,EA6BMzB,EAAEqB,MAAM,IA7BTK,EA6BaR,EAAEX,OA7BAiB,GAASE,GAAOD,GA8BrDzB,EAAEqB,MAAM,GAAKrB,EAAEqB,MAAM,IAAMH,EAAEX,KAAOP,EAAEqB,MAAM,IAC5CrB,EAAEqB,MAAM,GAAKrB,EAAEqB,MAAM,IAAMH,EAAEX,KAAOP,EAAEqB,MAAM,GA/BnC,IAACG,EAAOC,EAAKC,KAkCzB,OAAO,2BACFR,GADL,IAEEV,eACAE,iBAIJ,OAAO,2BACFpB,EAAMI,MADX,IAEEA,YAIuB,SAACC,GAAD,MAAe,CACxCgB,aAAc,SAACrC,EAAOqD,GAAR,OAAoBhC,EFtFT,SAACrB,EAAOqD,GAAR,MAAqB,CAC9C3D,KAlC2B,sBAmC3BC,QAAS,CAAEK,QAAOqD,YEoFyBC,CAAYtD,EAAOqD,KAC9Df,iBAAkB,SAACL,EAAMV,GAAP,OAAkBF,EFrHP,SAACY,EAAMV,GAAP,MAAmB,CAChD7B,KAH+B,0BAI/BC,QAAS,CAAEsC,OAAMV,SAAQmB,WAAY7C,gBEmHQ0D,CAAgBtB,EAAMV,QAGtDR,EA5Ef,YAQI,IAPFI,EAOC,EAPDA,WACAnE,EAMC,EANDA,MACAoE,EAKC,EALDA,KAGAiB,GAEC,EAJDmB,MAIC,EAHDC,YAGC,EAFDpB,cACAC,EACC,EADDA,iBAEA,OACE,yBAAK1B,UAAU,YAAYjC,MAAO,CAAE3B,QAAOC,OAAQD,IAChDoE,EAAKK,KAAI,SAACmB,GAAD,OACR,kBAACZ,EAAD,eACEL,IAAKiB,EAAEX,MACHW,EAFN,CAGEP,aAAcA,EACdC,iBAAkBA,EAClBxB,QAAS,kBAAMK,GAAcmB,EAAiBM,EAAEX,KAAMd,c,MC+DhE,IAiBeJ,eATS,SAACC,GAAD,MAAY,CAClC0C,QAAS1C,EAAMI,KAAKsC,QACpBxD,MAAOc,EAAMI,KAAKlB,MAClByD,UAAW3C,EAAMI,KAAKuC,UACtBC,KAAM5C,EAAMI,KAAKwC,KACjBC,gBAAiB7C,EAAMI,KAAKyC,gBAC5BC,kBAAmB9C,EAAMI,KAAK0C,sBAdL,SAACzC,GAAD,MAAe,CACxC0C,YAAa,kBAAM1C,EHzHY,CAC/B3B,KAAMI,KGyHNkE,iBAAkB,kBAAM3C,EHvHY,CACpC3B,KAjB8B,4BGwI9BuE,UAAW,SAAC/D,GAAD,OAAWmB,EHrGA,SAACnB,GAAD,MAAY,CAClCR,KAnCuB,kBAoCvBC,QAAS,CAAEO,UGmGoBgE,CAAShE,KACxCiE,SAAU,SAACP,GAAD,OAAUvC,EHlHC,SAACuC,GAAD,MAAW,CAChClE,KAtBsB,iBAuBtBC,QAAS,CAAEiE,SGgHkBQ,CAAQR,KACrCS,iBAAkB,SAACC,GAAD,OAAajD,EH/GF,SAACiD,GAAD,MAAc,CAC3C5E,KAxB+B,0BAyB/BC,QAAS,CAAE2E,YG6G6BC,CAAgBD,KACxDE,gBAAiB,SAACC,GAAD,OAAYpD,EH5GD,SAACoD,GAAD,MAAa,CACzC/E,KA3B8B,yBA4B9BC,QAAS,CAAE8E,WG0G2BC,CAAeD,QAWxC1D,EArGf,YAcI,IAbF2C,EAaC,EAbDA,QACAE,EAYC,EAZDA,KACA1D,EAWC,EAXDA,MACAyD,EAUC,EAVDA,UACAgB,EASC,EATDA,YACAb,EAQC,EARDA,kBACAC,EAOC,EAPDA,YACAF,EAMC,EANDA,gBACAM,EAKC,EALDA,SACAF,EAIC,EAJDA,UACAD,EAGC,EAHDA,iBACAK,EAEC,EAFDA,iBACAG,EACC,EADDA,gBAKAI,qBAAU,WACRC,UAAUC,aACPC,aAAa,CAAEC,MAAO,CAAEC,SAAUnB,KAClCoB,MAAK,SAACT,GAAD,OAAYD,EAAgBC,QACnC,CAACD,EAAiBV,IAErBc,qBAAU,WACJD,GACFE,UAAUC,aACPK,mBACAD,MAAK,SAACE,GAAD,OAASf,EAAiBe,QAEnC,CAACT,EAAaN,IAhBhB,MA1CH,WACE,IAAMgB,EAA6B,kBAAX/H,OAElBgI,EAAUC,uBAAY,WAC1B,MAAO,CACLvI,MAAOqI,EAAW/H,OAAOkI,gBAAaC,EACtCxI,OAAQoI,EAAW/H,OAAOoI,iBAAcD,KAEzC,CAACJ,IARmB,EAUaM,mBAASL,GAVtB,mBAUhBM,EAVgB,KAUJC,EAVI,KAyBvB,OAdAjB,qBAAU,WACR,IAAKS,EACH,OAAO,EAGT,SAASS,IACPD,EAAcP,KAKhB,OAFAhI,OAAOyI,iBAAiB,SAAUD,GAE3B,kBAAMxI,OAAO0I,oBAAoB,SAAUF,MACjD,CAACR,EAASD,IAENO,EAmCmBK,GAAlBjJ,EAlBP,EAkBOA,MAAOC,EAlBd,EAkBcA,OACTiJ,EAAY/H,KAAKa,IAAI,IAAOhC,EAAOC,EAAS,KAE5CkJ,EAAatC,EAAgBuC,QAAO,SAACC,EAAKC,GAI9C,MAHiB,eAAbA,EAAIC,OACNF,EAAIC,EAAIE,OAASF,EAAIrB,UAEhBoB,IACN,IAEGI,EAAM/C,EAAU,QAAU,GAChC,OACE,yBAAK9C,UAAU,WACb,4BAAQA,UAAU,YAChB,4BAAQA,UAAS,qBAAgB6F,GAAO3F,QAASiD,IAEjD,kBAAC,IAAD,CACE2C,MAAM,QACN1J,MAAe,GAARA,EACP2J,SAAU,SAAChF,EAAKyB,GACF,UAARzB,GACFsC,EAAUb,GAEA,cAARzB,GACFqC,IAEU,SAARrC,GACFwC,EAASf,IAGbpC,MAAO,CACLd,QACA0D,OACAD,cAGF,kBAAC,QAAD,CAAO6C,MAAM,QAAQxH,IAAK,GAAIC,IAAK,IAAKf,KAAM,IAC9C,kBAAC,QAAD,CAAOsI,MAAM,OAAOxH,IAAK,EAAGC,IAAK,IACjC,kBAAC,WAAD,CAAUuH,MAAM,cAChB,kBAAC,SAAD,CAAQA,MAAM,QAAQI,QAAST,MAGnC,yBAAKvF,UAAU,OACb,kBAACiG,EAAA,EAAD,CAAaC,QAASC,KACpB,kBAAC,EAAD,CAAW/J,MAAOkJ,EAAWc,WAAY,IACzC,kBAAC,EAAD,CAAWhK,MAAOA,EAAQkJ,U,eC/H9Be,EAAe,CACnBhG,MAAO,ICST3D,OAAO4J,UAAY,GAEnB,IAsBsB1D,EAAOC,EAtBvBwD,EAAe,CACnBxD,YAAa,EACbD,MAAO,GACPE,SAAS,EACTC,WAAW,EACXzD,MAAO,OACPiH,kBAAmB,EACnBvD,KAAM,GAGNzC,WAAY,KAEZ2C,kBAAmB,KACnBD,gBAAiB,GACjBc,YAAa,KAEbvD,MAMoBoC,EAND,GAMQC,EANJ,EAOhB,YAAI2D,MAAM5D,GAAO6D,QAAQ5F,KAAI,SAACQ,GAGnC,MAAO,CACLA,KAAMA,EAAO,EACbE,SAJeF,EAAO,GAAKwB,EAK3BvB,aAAc,SAKL,IC5CAoF,cAAgB,CAC7BpG,KFCa,WAAmC,IAAlCF,EAAiC,uDAAzBiG,EAAcM,EAAW,uCAC/C,OAAQA,EAAO7H,MACb,ILNuB,oBKQrB,OAAO,2BACFsB,GADL,IAEEC,MAAM,CAAEsG,EAAO5H,SAAV,mBAAsBqB,EAAMC,UAErC,QACE,OAAOD,IETXI,KD0Ca,WAAmC,IAAlCJ,EAAiC,uDAAzBiG,EAAcM,EAAW,uCAC/C,OAAQA,EAAO7H,MACb,ILzCyB,sBK4CvB,OADApC,OAAO4J,UAAUK,EAAO5H,QAAQK,MAAQ,GAAKuH,EAAO5H,QAAQ0D,QACrDrC,EACT,IL5C6B,0BK6C3B,IAAMI,EAAI,YAAOJ,EAAMI,MACjBoG,EAAWpG,EAAKmG,EAAO5H,QAAQsC,KAAO,GAM5C,OALAuF,EAAStF,aAAauF,KAAK,CACzBjI,GAAI+H,EAAO5H,QAAQ4B,OACnBmB,WAAY6E,EAAO5H,QAAQ+C,aAGtB,2BACF1B,GADL,IAEEI,SAEJ,IL/D4B,yBKgE1B,OAAO,2BACFJ,GADL,IAEE2C,WAAY3C,EAAM2C,YAEtB,KAAK7D,EACH,OAAO,2BACFkB,GADL,IAEE0C,SAAU1C,EAAM0C,UAEpB,ILtE2B,wBKuEzB,OAAO,2BACF1C,GADL,IAEEG,WAAYoG,EAAO5H,QAAQ4B,SAE/B,IL5EoB,iBK6ElB,OAAO,2BACFP,GADL,IAEE4C,KAAM2D,EAAO5H,QAAQiE,OAEzB,IL/E6B,0BKgF3B,OAAO,2BACF5C,GADL,IAEE6C,gBAAiB0D,EAAO5H,QAAQ2E,UAEpC,ILnF4B,yBKqF1B,OADAoD,QAAQC,IAAIJ,EAAO5H,SACZ,2BACFqB,GADL,IAEE2D,YAAa4C,EAAO5H,QAAQ8E,SAEhC,IL7FqB,kBK8FnB,OAAO,2BACFzD,GADL,IAEEd,MAAOqH,EAAO5H,QAAQO,QAE1B,QACE,OAAOc,MEyBb,IAgIe4G,EAhIQ,SAACC,GAAD,OAAW,SAACC,GACjC,IACIC,EACAC,EAEAC,EACAC,EALAC,EAAQ,KAONjH,EAAO,SAAPA,IACJ,IAAMkH,EAAW9K,OAAO8K,UAAY,IAAIC,aACxC/K,OAAO8K,SAAWA,EAClB,IAAMpH,EAAQ6G,EAAMS,WAHH,EAebtH,EAAMI,KAVRuD,EALe,EAKfA,YAEAjB,EAPe,EAOfA,QACAC,EARe,EAQfA,UACAzD,EATe,EASfA,MACAkB,EAVe,EAUfA,KACAwC,EAXe,EAWfA,KACAJ,EAZe,EAYfA,MACAC,EAbe,EAafA,YACA0D,EAde,EAcfA,kBAEMlG,EAAUD,EAAME,KAAhBD,MACFsH,EAAiB,GAAOrI,EAE9B,IACE,IAAMsI,EAAQJ,EAASK,YAKvB,GAAI/E,GAAWuE,EAAqBO,GAnJd,IAmJ2C,CAC/D,IAAIE,EAAWR,EAAe,GACZ,IAAdQ,IACFA,EAAWlF,EAAQ,GAGrBlG,OAAO4J,UAAUwB,GAAUC,UAAUC,OAAO,UAC5CtL,OAAO4J,UAAUgB,GAAcS,UAAUE,IAAI,UAE7CX,GAAgB,EAChBA,GAAgB1E,EAChByE,GAAsBM,EAMxB,GAAI7E,GAAWqE,EAAeS,EAtKR,GAsKqC,CAczD,GAhKR,SACEpH,EACAH,EACA+G,EACAxE,EACA4E,EACAxE,EACAmE,GAEyB3G,EAAK4G,EAAWxE,GAAjCtB,aAGLT,KAAI,gBAAGjC,EAAH,EAAGA,GAAH,OAAYyB,EAAM6B,MAAK,SAACpB,GAAD,OAAOA,EAAElC,KAAOA,QAC3CsJ,SAAQ,YAAiB,IAAd/L,EAAa,EAAbA,OACJgM,EAASX,EAASY,qBAGxBD,EAAOhM,OAASA,EAIhB,IAAMkM,EAAWb,EAASc,aAC1BD,EAASrF,KAAKuF,eAAevF,EAAMwE,EAASK,aAC5CM,EAAOhI,QAAQkI,GAAUlI,QAAQqH,EAASgB,aAC1CL,EAAO7F,MAAM6E,MA4HXsB,CACEjI,EACAH,EACA+G,EACAxE,EACA4E,EACAxE,EACAmE,GAKEC,EAAWb,IAAsB,EAAG,CACtC,IAAMmC,EAAYvB,EACZwB,EAAUxB,EAAeZ,EAAoBoB,EAEnDb,QAAQC,IAAR,qBAA0B2B,EAA1B,cAAyCC,IAxInD,SAA2B9E,EAAQ2D,EAAUlF,EAAOC,GAClD,IAAMqG,EAAW,IAAIC,cAAchF,GAC7BiF,EAAkBvG,EAAMiF,EAASK,YAavC,OAVAe,EAAStG,MAAoD,KAA7CwG,EAAkB,KAU3B,IAAIC,SACT,SAACC,GAAD,OACGJ,EAASK,gBAAkB,SAACC,GAIJ,cAAnBN,EAASxI,OACXwI,EAASO,OAEXH,EAAQE,EAAIjL,UAGfqG,MAAK,SAAC8E,GAAD,OAAOA,EAAEC,iBACd/E,MAAK,SAAC8E,GAAD,OAAO,IAAIL,SAAQ,SAACO,EAAGC,GAAJ,OAAY/B,EAASgC,gBAAgBJ,EAAGE,EAAGC,SACnEjF,MAAK,SAAC8E,GAYL,IAPA,IAAMK,EAAaL,EAAEzJ,SAAWmJ,EAlFV,GAoFhBY,EAAaN,EAAEM,WACfC,EAAoBnC,EAASoC,aAAa,GAAIrH,EAAMD,GAASoH,EAAYA,GAEzEG,EAAOF,EAAkBtM,eAAe,GACxCyM,EAAMV,EAAE/L,eAAe,GACpB0M,EAAI,EAAGA,GAAKxH,EAAMD,GAASoH,EAAYK,IAC9CF,EAAKE,GAAKD,EAAIC,EAAIxM,KAAKM,MAAM4L,EAAYC,IAG3C,OAAOC,KA8FHK,CACEjG,EACAyD,EACAkB,EACAC,GACArE,MAAK,SAAC8E,GAAD,OAAOnC,EAAMxG,SAAS5B,EAAWuK,OAItCrG,GAhMZ,SAA0ByE,EAAUyC,EAAGC,EAAMtH,EAAOC,GAClD,IAAMsH,EAAM3C,EAAS4C,mBACrBD,EAAIhK,QAAQqH,EAASgB,aAGnB2B,EAAIE,UAAUC,MADZL,EAAIrH,IAAU,EACM,IACbqH,EAAIpH,IAAgB,EACP,IAEA,IAGxBsH,EAAI7H,MAAM4H,GACVC,EAAIhB,KAAKe,EAhBS,KAoMVK,CACE/C,EACAJ,EACAD,EACAvE,EACAC,GAIJuE,GAAY,EACZA,GAAYxE,EAEZuE,GAAgBQ,GAlEpB,QAwEEJ,EAAQiD,sBAAsBlK,KAIlC,OAAO,SAACqG,GASN,GAHAO,EAAKP,GAGDA,EAAO7H,OAASI,GAAe+H,EAAMS,WAAWlH,KAAKsC,QAAS,CAChE,IAAM0E,EAAW9K,OAAO8K,UAAY,IAAIC,aACxC/K,OAAO8K,SAAWA,EAElBJ,EAAW,EACXE,EAAe,EACfH,EAAeK,EAASK,YA1OF,GA2OtBR,EAAqBG,EAASK,YA3OR,GA4OtBN,EAAQiD,sBAAsBlK,QACrBqG,EAAO7H,OAASI,GAAeqI,IACxC7K,OAAO4J,UAAU4B,SAAQ,SAACuC,GAAD,OAAUA,EAAK1C,UAAUC,OAAO,aACzD0C,qBAAqBnD,OC/OPoD,QACW,cAA7BjO,OAAOkO,SAASC,UAEe,UAA7BnO,OAAOkO,SAASC,UAEhBnO,OAAOkO,SAASC,SAASC,MACvB,2DCRNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,IAAD,CAAUhE,MCPC,WAA4C,IAApBZ,EAAmB,uDAAJ,GACpD,OAAO6E,YAAYC,EAAa9E,EAAc+E,YAAgBpE,IDM3CqE,IACf,kBAAC,EAAD,QAGJC,SAASC,eAAe,SDmHpB,kBAAmBtH,WACrBA,UAAUuH,cAAcC,MACrBnH,MAAK,SAAAoH,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACL/E,QAAQ+E,MAAMA,EAAMC,c","file":"static/js/main.30e2340d.chunk.js","sourcesContent":["import React, { useRef, useLayoutEffect, memo } from \"react\";\n\nconst Waveform = (props = {}) => {\n  const {\n    buffer = null,\n    width = 500,\n    height = 100,\n    zoom = 1,\n    color = \"black\",\n    onDone = null,\n    pixelRatio = window.devicePixelRatio,\n  } = props;\n\n  const canvas = useRef(null);\n\n  useLayoutEffect(() => {\n    const context = canvas.current.getContext(\"2d\");\n\n    var w = width * zoom;\n    var middle = height / 2.0;\n\n    var channelData = buffer.getChannelData(0);\n    var step = Math.ceil(channelData.length / w);\n\n    context.fillStyle = color;\n    draw(width, step, middle, channelData, context);\n\n    if (onDone) {\n      onDone();\n    }\n  });\n\n  const dw = Math.floor(pixelRatio * width * zoom);\n  const dh = Math.floor(pixelRatio * height);\n  const style = { width: width * zoom, height };\n  return <canvas ref={canvas} width={dw} height={dh} style={style} />;\n};\n\nfunction draw(width, step, middle, data, ctx) {\n  for (var i = 0; i < width; i += 1) {\n    var min = 1.0;\n    var max = -1.0;\n\n    for (var j = 0; j < step; j += 1) {\n      var datum = data[i * step + j];\n\n      if (datum < min) {\n        min = datum;\n      } else if (datum > max) {\n        max = datum;\n      }\n\n      ctx.fillRect(i, (1 + min) * middle, 1, Math.max(1, (max - min) * middle));\n    }\n  }\n}\n\n// Use the loop ID equality as a proxy for the buffer equality\nexport default memo(\n  (props) => <Waveform {...props} />,\n  (prevProps, nextProps) => \n    (\n      prevProps.id === nextProps.id &&\n      prevProps.width === nextProps.width &&\n      prevProps.height === nextProps.height &&\n      prevProps.color === nextProps.color\n    )\n  \n);\n","import { v4 as uuidv4 } from \"uuid\";\nimport randomColor from \"randomcolor\";\nexport const CREATE_LOOP = \"@GRID/CREATE_LOOP\";\n\nexport const createLoop = (buffer) => ({\n  type: CREATE_LOOP,\n  payload: {\n    buffer,\n    color: randomColor(),\n    id: uuidv4(),\n  },\n});\n","import { v4 as uuidv4 } from \"uuid\";\n\nexport const TOGGLE_PLAY = '@GRID/TOGGLE_PLAY';\nexport const TOGGLE_METRONOME = '@GRID/TOGGLE_METRONOME';\nexport const SET_TEMPO = '@GRID/SET_TEMPO';\nexport const SET_GAIN = '@GRID/SET_GAIN';\nexport const SET_ACTIVE_LOOP = '@GRID/SET_ACTIVE_LOOP';\nexport const SET_INPUT_DEVICES = '@GRID/SET_INPUT_DEVICES';\nexport const SET_MEDIA_STREAM = '@GRID/SET_MEDIA_STREAM';\nexport const SET_GRID_ELEM = '@GRID/SET_GRID_ELEM';\nexport const ADD_LOOP_INSTANCE = '@GRID/ADD_LOOP_INSTANCE';\n\nexport const addLoopInstance = (beat, loopId) => ({\n  type: ADD_LOOP_INSTANCE,\n  payload: { beat, loopId, instanceId: uuidv4() }\n});\nexport const togglePlay = () => ({\n  type: TOGGLE_PLAY,\n});\nexport const toggleMetronome = () => ({\n  type: TOGGLE_METRONOME,\n});\nexport const setActiveLoop = (loopId) => ({\n  type: SET_ACTIVE_LOOP,\n  payload: { loopId }\n});\nexport const setGain = (gain) => ({\n  type: SET_GAIN,\n  payload: { gain }\n});\nexport const setInputDevices = (devices) => ({\n  type: SET_INPUT_DEVICES,\n  payload: { devices }\n});\nexport const setMediaStream = (stream) => ({\n  type: SET_MEDIA_STREAM,\n  payload: { stream }\n});\nexport const setTempo = (tempo) => ({\n  type: SET_TEMPO,\n  payload: { tempo }\n});\nexport const setGridElem = (index, domElem) => ({\n  type: SET_GRID_ELEM,\n  payload: { index, domElem }\n});\n","import React, { useEffect } from \"react\";\nimport { useDrag } from \"react-dnd\";\nimport { connect } from \"react-redux\";\n\nimport Waveform from \"./Waveform\";\n\nimport { createLoop } from \"../actions/loop\";\nimport { setActiveLoop } from \"../actions/grid\";\n\n// var audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n// function getData() {\n//   const request = new XMLHttpRequest();\n//   request.open(\"GET\", \"Amen-break.mp3\", true);\n//   request.responseType = \"arraybuffer\";\n//\n//   return new Promise((resolve, reject) => {\n//     request.onload = function () {\n//       const audioData = request.response;\n//\n//       audioCtx.decodeAudioData(\n//         audioData,\n//         function (buffer) {\n//           resolve(buffer);\n//         },\n//         function (e) {\n//           reject(\"Error with decoding audio data\" + e.err);\n//         }\n//       );\n//     };\n//\n//     request.send();\n//   });\n// }\n\nfunction Loop({\n  id,\n  index,\n  length,\n  active,\n  color,\n  buffer,\n  width,\n  height,\n  tempo,\n  setActiveLoopA,\n}) {\n  const beatDuration = 60.0 / tempo;\n  const lengthInBeats = Math.round(buffer.duration / beatDuration);\n\n  // Allow loops to be dragged onto the grid\n  const [{ opacity }, drag] = useDrag({\n    item: { id, type: 'LOOP' },\n  });\n\n  return (\n    <div\n      ref={drag}\n      className={`Loop ${active ? \"active\" : \"\"}`}\n      style={{ opacity, height, width, paddingTop: 20 }}\n      onClick={() => setActiveLoopA(id)}\n    >\n      <Waveform\n        id={id}\n        width={width}\n        height={height - 20}\n        color={color}\n        buffer={buffer}\n      />\n      <div>Loop {index} {'//'} {lengthInBeats} beats</div>\n    </div>\n  );\n}\n\nfunction LoopPanel({ loops, width, tempo, activeLoop, createLoopA, setActiveLoopA }) {\n  const height = 75;\n\n  // useEffect(() => {\n  //   getData().then((buffer) => createLoopA(buffer));\n  // }, [createLoopA]);\n\n  return (\n    <div className=\"LoopPanel\" style={{ width }}>\n      {loops.map((l, index) => (\n        <Loop\n          key={l.id}\n          index={index}\n          setActiveLoopA={setActiveLoopA}\n          active={activeLoop === l.id}\n          {...l}\n          tempo={tempo}\n          width={width - 20}\n          height={height}\n        />\n      ))}\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => ({\n  loops: state.loop.loops,\n  activeLoop: state.grid.activeLoop,\n  tempo: state.grid.tempo,\n});\nconst mapDispatchToProps = (dispatch) => ({\n  createLoopA: (buffer) => dispatch(createLoop(buffer)),\n  setActiveLoopA: (loopId) => dispatch(setActiveLoop(loopId)),\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(LoopPanel);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { useDrop } from \"react-dnd\";\n\nimport { setGridElem, addLoopInstance } from \"../actions/grid\";\n\nfunction GridLoopMarker({ id, color, soft, numMarkers }) {\n  const opacity = soft ? 0.3 : 1;\n  return (\n    <div\n      className={`GridLoopMarker ${numMarkers > 4 ? 'half' : ''}`}\n      style={{ backgroundColor: color, opacity }}\n    />\n  );\n}\n\nfunction Grid({\n  beat,\n  barBeat,\n  loopTriggers,\n  loopTails,\n  activeLoop,\n  setGridElemA,\n  addLoopInstanceA,\n  onClick,\n}) {\n\n  // Add loop instances when they are dragged onto the grid\n  const drop = useDrop({\n    accept: ['LOOP'],\n    drop: (item) => addLoopInstanceA(beat, item.id)\n  })[1];\n\n  const numMarkers = loopTriggers.length + loopTails.length;\n\n  // Save a ref (into redux) so the scheduler can manipule the \"active\" class to\n  // animate the sequencer\n  return (\n    <div\n      ref={(ref) => {\n        setGridElemA(beat, ref);\n        drop(ref);\n      }}\n      className=\"Grid\"\n      onClick={onClick}\n    >\n      {loopTriggers.map((l) => (\n        <GridLoopMarker key={l.instanceId} {...l} numMarkers={numMarkers} />\n      ))}\n      {loopTails.map((l) => (\n        <GridLoopMarker key={l.instanceId} {...l} soft={true} numMarkers={numMarkers} />\n      ))}\n    </div>\n  );\n}\n\nfunction GridPanel({\n  activeLoop,\n  width,\n  grid,\n  beats,\n  beatsPerBar,\n  setGridElemA,\n  addLoopInstanceA,\n}) {\n  return (\n    <div className=\"GridPanel\" style={{ width, height: width }}>\n      {grid.map((g) => (\n        <Grid\n          key={g.beat}\n          {...g}\n          setGridElemA={setGridElemA}\n          addLoopInstanceA={addLoopInstanceA}\n          onClick={() => activeLoop && addLoopInstanceA(g.beat, activeLoop)}\n        />\n      ))}\n    </div>\n  );\n}\n\nconst inRange = (start, end, val) => val >= start && val <= end;\n\nconst mapStateToProps = (state) => {\n  const tempo = state.grid.tempo;\n\n  const activeLoops = state.grid.grid\n    .map((g) =>\n      g.loopTriggers.map(({ id, instanceId }) => {\n        const originLoop = state.loop.loops.find((l) => l.id === id);\n        const beatDuration = 60.0 / tempo;\n        const lengthInBeats = Math.round(originLoop.buffer.duration / beatDuration);\n\n        const range = [\n          g.beat,\n          (g.beat + lengthInBeats - 1) % state.grid.grid.length,\n        ];\n\n        return {\n          range,\n          instanceId,\n          ...originLoop,\n        };\n      })\n    )\n    .flat();\n\n  const grid = state.grid.grid.map((g) => {\n    const loopTriggers = activeLoops.filter((l) => l.range[0] === g.beat);\n    const loopTails = activeLoops.filter((l) =>\n      inRange(l.range[0] + 1, l.range[1], g.beat) ||\n      (l.range[0] > l.range[1] && g.beat > l.range[0]) ||\n      (l.range[0] > l.range[1] && g.beat < l.range[1])\n    );\n\n    return {\n      ...g,\n      loopTriggers,\n      loopTails,\n    };\n  });\n\n  return {\n    ...state.grid,\n    grid,\n  };\n};\n\nconst mapDispatchToProps = (dispatch) => ({\n  setGridElemA: (index, domElem) => dispatch(setGridElem(index, domElem)),\n  addLoopInstanceA: (beat, loopId) => dispatch(addLoopInstance(beat, loopId)),\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(GridPanel);\n","import React, { useEffect, useState, useCallback } from \"react\";\nimport { connect } from \"react-redux\";\nimport { DndProvider } from \"react-dnd\";\nimport Backend from \"react-dnd-html5-backend\";\n\nimport ReactControlPanel, {\n  Select,\n  Range,\n  Checkbox,\n} from \"react-control-panel\";\n\nimport LoopPanel from \"./components/LoopPanel\";\nimport GridPanel from \"./components/GridPanel\";\nimport \"./App.css\";\n\nimport {\n  setTempo,\n  togglePlay,\n  toggleMetronome,\n  setGain,\n  setInputDevices,\n  setMediaStream,\n} from \"./actions/grid\";\n\nfunction useWindowSize() {\n  const isClient = typeof window === \"object\";\n\n  const getSize = useCallback(() => {\n    return {\n      width: isClient ? window.innerWidth : undefined,\n      height: isClient ? window.innerHeight : undefined,\n    };\n  }, [isClient]);\n\n  const [windowSize, setWindowSize] = useState(getSize);\n  useEffect(() => {\n    if (!isClient) {\n      return false;\n    }\n\n    function handleResize() {\n      setWindowSize(getSize());\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, [getSize, isClient]);\n\n  return windowSize;\n}\n\nfunction App({\n  playing,\n  gain,\n  tempo,\n  metronome,\n  mediaStream,\n  activeInputDevice,\n  togglePlayA,\n  inputDeviceList,\n  setGainA,\n  setTempoA,\n  toggleMetronomeA,\n  setInputDevicesA,\n  setMediaStreamA,\n}) {\n  //\n  // Get permission to access input audio stream\n  //\n  useEffect(() => {\n    navigator.mediaDevices\n      .getUserMedia({ audio: { deviceId: activeInputDevice } })\n      .then((stream) => setMediaStreamA(stream));\n  }, [setMediaStreamA, activeInputDevice]);\n\n  useEffect(() => {\n    if (mediaStream) {\n      navigator.mediaDevices\n        .enumerateDevices()\n        .then((res) => setInputDevicesA(res));\n    }\n  }, [mediaStream, setInputDevicesA]);\n\n  const { width, height } = useWindowSize();\n  const gridWidth = Math.min(0.75 * width, height - 120);\n\n  const deviceOpts = inputDeviceList.reduce((acc, dev) => {\n    if (dev.kind === \"audioinput\") {\n      acc[dev.label] = dev.deviceId;\n    }\n    return acc;\n  }, {});\n\n  const cls = playing ? \"pause\" : \"\";\n  return (\n    <div className=\"Wrapper\">\n      <header className=\"Controls\">\n        <button className={`PlayButton ${cls}`} onClick={togglePlayA} />\n\n        <ReactControlPanel\n          theme=\"light\"\n          width={width * 0.6}\n          onChange={(key, val) => {\n            if (key === \"tempo\") {\n              setTempoA(val);\n            }\n            if (key === \"metronome\") {\n              toggleMetronomeA();\n            }\n            if (key === \"gain\") {\n              setGainA(val);\n            }\n          }}\n          state={{\n            tempo,\n            gain,\n            metronome,\n          }}\n        >\n          <Range label=\"tempo\" min={40} max={260} step={1} />\n          <Range label=\"gain\" min={0} max={1} />\n          <Checkbox label=\"metronome\" />\n          <Select label=\"input\" options={deviceOpts} />\n        </ReactControlPanel>\n      </header>\n      <div className=\"App\">\n        <DndProvider backend={Backend}>\n          <GridPanel width={gridWidth} activeBeat={0} />\n          <LoopPanel width={width - gridWidth} />\n        </DndProvider>\n      </div>\n    </div>\n  );\n}\n\nconst mapDispatchToProps = (dispatch) => ({\n  togglePlayA: () => dispatch(togglePlay()),\n  toggleMetronomeA: () => dispatch(toggleMetronome()),\n  setTempoA: (tempo) => dispatch(setTempo(tempo)),\n  setGainA: (gain) => dispatch(setGain(gain)),\n  setInputDevicesA: (devices) => dispatch(setInputDevices(devices)),\n  setMediaStreamA: (stream) => dispatch(setMediaStream(stream)),\n});\nconst mapStateToProps = (state) => ({\n  playing: state.grid.playing,\n  tempo: state.grid.tempo,\n  metronome: state.grid.metronome,\n  gain: state.grid.gain,\n  inputDeviceList: state.grid.inputDeviceList,\n  activeInputDevice: state.grid.activeInputDevice,\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n","import { CREATE_LOOP } from \"../actions/loop\";\n\nconst initialState = {\n  loops: [],\n};\n\nexport default (state = initialState, action) => {\n  switch (action.type) {\n    case CREATE_LOOP:\n      // TODO: Limit to 10 loops (need to save the ones that are instantiated on the grid\n      return {\n        ...state,\n        loops: [action.payload, ...state.loops],\n      };\n    default:\n      return state;\n  }\n};\n","import {\n  TOGGLE_PLAY,\n  TOGGLE_METRONOME,\n  SET_ACTIVE_LOOP,\n  SET_GAIN,\n  SET_TEMPO,\n  SET_INPUT_DEVICES,\n  SET_MEDIA_STREAM,\n  SET_GRID_ELEM,\n  ADD_LOOP_INSTANCE,\n} from \"../actions/grid\";\n\nwindow.gridElems = [];\n\nconst initialState = {\n  beatsPerBar: 4,\n  beats: 16,\n  playing: false,\n  metronome: true,\n  tempo: 136.55,\n  quantizationBeats: 4,\n  gain: 0.2,\n\n  // The highlighted loop that will be added to the grid when its clicked\n  activeLoop: null,\n\n  activeInputDevice: null,\n  inputDeviceList: [],\n  mediaStream: null,\n\n  grid: generateGrid(16, 4),\n  // gridElems: [],\n};\n\n// TODO: Seemless switching betweeen resolutions - different state per view\n\nfunction generateGrid(beats, beatsPerBar) {\n  return [...Array(beats).keys()].map((beat) => {\n    const barBeat = (beat + 1) % beatsPerBar;\n\n    return {\n      beat: beat + 1,\n      barBeat,\n      loopTriggers: [],\n    };\n  });\n}\n\nexport default (state = initialState, action) => {\n  switch (action.type) {\n    case SET_GRID_ELEM:\n      // Mutate in place as these are opaque refs\n      window.gridElems[action.payload.index - 1] = action.payload.domElem;\n      return state;\n    case ADD_LOOP_INSTANCE:\n      const grid = [...state.grid];\n      const gridItem = grid[action.payload.beat - 1];\n      gridItem.loopTriggers.push({\n        id: action.payload.loopId,\n        instanceId: action.payload.instanceId,\n      });\n\n      return {\n        ...state,\n        grid,\n      };\n    case TOGGLE_METRONOME:\n      return {\n        ...state,\n        metronome: !state.metronome,\n      };\n    case TOGGLE_PLAY:\n      return {\n        ...state,\n        playing: !state.playing,\n      };\n    case SET_ACTIVE_LOOP:\n      return {\n        ...state,\n        activeLoop: action.payload.loopId,\n      };\n    case SET_GAIN:\n      return {\n        ...state,\n        gain: action.payload.gain,\n      };\n    case SET_INPUT_DEVICES:\n      return {\n        ...state,\n        inputDeviceList: action.payload.devices,\n      };\n    case SET_MEDIA_STREAM:\n      console.log(action.payload);\n      return {\n        ...state,\n        mediaStream: action.payload.stream,\n      };\n    case SET_TEMPO:\n      return {\n        ...state,\n        tempo: action.payload.tempo,\n      };\n    default:\n      return state;\n  }\n};\n","import { combineReducers } from \"redux\";\nimport loopReducer from \"./loopReducer\";\nimport gridReducer from \"./gridReducer\";\n\nexport default combineReducers({\n  loop: loopReducer,\n  grid: gridReducer,\n});\n","//\n// Middleware that handles scheduling all the active loops to play at the correct times. It\n// reacts to changes in the redux state while maintaining a consistent beat.\n//\n// We also manage DOM updates of the grid & loop cursors based on the beat. We want to avoid\n// using React's reconciler for this as it schedules updates for a later point when we want\n// to prioritise frame-level precision of which grid square is lit up\n//\n\nimport { TOGGLE_PLAY } from \"../actions/grid\";\nimport { createLoop } from \"../actions/loop\";\n\nconst SCHEDULE_AHEAD_TIME = 0.1;\nconst BLIP_LENGTH = 0.01;\nconst ANIMATION_TOLERANCE = -0.05;\n\nfunction triggerMetronome(audioCtx, b, time, beats, beatsPerBar) {\n  const osc = audioCtx.createOscillator();\n  osc.connect(audioCtx.destination);\n\n  if (b % beats === 0) {\n    osc.frequency.value = 880.0;\n  } else if (b % beatsPerBar === 0) {\n    osc.frequency.value = 440.0;\n  } else {\n    osc.frequency.value = 220.0;\n  }\n\n  osc.start(time);\n  osc.stop(time + BLIP_LENGTH);\n}\n\nfunction triggerLoopsAtBeat(\n  grid,\n  loops,\n  nextBeat,\n  beats,\n  audioCtx,\n  gain,\n  nextNoteTime\n) {\n  const { loopTriggers } = grid[nextBeat % beats];\n\n  loopTriggers\n    .map(({ id }) => loops.find((l) => l.id === id))\n    .forEach(({ buffer }) => {\n      const source = audioCtx.createBufferSource();\n\n      // set the buffer in the AudioBufferSourceNode\n      source.buffer = buffer;\n\n      // TODO: Find a better place to apply global gain\n      // start the source playing\n      const gainNode = audioCtx.createGain();\n      gainNode.gain.setValueAtTime(gain, audioCtx.currentTime);\n      source.connect(gainNode).connect(audioCtx.destination);\n      source.start(nextNoteTime);\n    });\n}\n\nfunction recordInputStream(stream, audioCtx, start, end) {\n  const recorder = new MediaRecorder(stream);\n  const secondsUntilEnd = end - audioCtx.currentTime;\n\n  // This should record the full loop with a small gap at the start and end\n  recorder.start((secondsUntilEnd + 2 * SCHEDULE_AHEAD_TIME) * 1000);\n\n  // let s1, s2;\n  // let e1, e2;\n  //\n  // s1 = audioCtx.currentTime;\n  // recorder.onstart = (evt) => {\n  //   s2 = evt.timeStamp / 1000;\n  // };\n\n  return new Promise(\n    (resolve) =>\n      (recorder.ondataavailable = (evt) => {\n        // e1 = audioCtx.currentTime;\n        // e2 = evt.timeStamp / 1000;\n\n        if (recorder.state === \"recording\") {\n          recorder.stop();\n        }\n        resolve(evt.data);\n      })\n  )\n    .then((d) => d.arrayBuffer())\n    .then((d) => new Promise((r, err) => audioCtx.decodeAudioData(d, r, err)))\n    .then((d) => {\n      // const startOffset = (s2 - s1) - SCHEDULE_AHEAD_TIME;\n      // const endOffset = e2 - e1 - SCHEDULE_AHEAD_TIME;\n      // const loopLength = end - start;\n      // console.log(d.duration, secondsUntilEnd + 2* SCHEDULE_AHEAD_TIME, loopLength, startOffset);\n      const durOffset = (d.duration - secondsUntilEnd) + SCHEDULE_AHEAD_TIME;\n\n      const sampleRate = d.sampleRate;\n      const outputAudioBuffer = audioCtx.createBuffer(1, (end - start) * sampleRate, sampleRate);\n\n      const outB = outputAudioBuffer.getChannelData(0);\n      const inB = d.getChannelData(0);\n      for (let t = 0; t < (end - start) * sampleRate; t++) {\n        outB[t] = inB[t + Math.floor(durOffset * sampleRate)];\n      }\n\n      return outputAudioBuffer;\n    });\n\n  // return rawRecordingP;\n\n  // const [delay, recording] = Promise.all([startDelayP, rawRecordingP]);\n  // return recording;\n  // .then((d) => {\n  //   const sampleRate = 44100;\n  //   const outputAudioBuffer = audioCtx.createBuffer(2, (end - start) * sampleRate, sampleRate);\n  //\n  //   for (let channel = 0; channel < 2; channel++) {\n  //     const channelBuffer = outputAudioBuffer.getChannelData(channel);\n  //\n  //     // for (let t = 0; t < (end - start); t++) {\n  //       // channelBuffer[t] = d[channel][t\n  //     // }\n  //   }\n  //\n  //   return outputAudioBuffer;\n  // });\n}\n\nconst audioScheduler = (store) => (next) => {\n  let frame = null;\n  let nextNoteTime;\n  let nextBeat;\n\n  let nextGridChangeTime;\n  let nextGridBeat;\n\n  const loop = () => {\n    const audioCtx = window.audioCtx || new AudioContext();\n    window.audioCtx = audioCtx;\n    const state = store.getState();\n    const {\n      mediaStream,\n\n      playing,\n      metronome,\n      tempo,\n      grid,\n      gain,\n      beats,\n      beatsPerBar,\n      quantizationBeats,\n    } = state.grid;\n    const { loops } = state.loop;\n    const secondsPerBeat = 60.0 / tempo;\n\n    try {\n      const cTime = audioCtx.currentTime;\n\n      //\n      // Manage visual animations in real-time\n      //\n      if (playing && nextGridChangeTime < cTime + ANIMATION_TOLERANCE) {\n        let prevBeat = nextGridBeat - 1;\n        if (prevBeat === -1) {\n          prevBeat = beats - 1;\n        }\n\n        window.gridElems[prevBeat].classList.remove(\"active\");\n        window.gridElems[nextGridBeat].classList.add(\"active\");\n\n        nextGridBeat += 1;\n        nextGridBeat %= beats;\n        nextGridChangeTime += secondsPerBeat;\n      }\n\n      //\n      // Manage audio triggering using a look-ahead scheduler\n      //\n      if (playing && nextNoteTime < cTime + SCHEDULE_AHEAD_TIME) {\n        // Get notes at \"nextBeat\" and schedule them to play in the webAudio audioCtx\n        triggerLoopsAtBeat(\n          grid,\n          loops,\n          nextBeat,\n          beats,\n          audioCtx,\n          gain,\n          nextNoteTime\n        );\n\n        // At this point, we lock in the current state in redux as what audio will be scheduled\n        // regardless of user changes.\n        if (nextBeat % quantizationBeats === 0) {\n          const loopStart = nextNoteTime;\n          const loopEnd = nextNoteTime + quantizationBeats * secondsPerBeat;\n\n          console.log(`New loop - ${loopStart} / ${loopEnd}`);\n\n          // Start recording the next loop\n          recordInputStream(\n            mediaStream,\n            audioCtx,\n            loopStart,\n            loopEnd\n          ).then((d) => store.dispatch(createLoop(d)));\n        }\n\n        // Trigger metronome on each beat\n        if (metronome) {\n          triggerMetronome(\n            audioCtx,\n            nextBeat,\n            nextNoteTime,\n            beats,\n            beatsPerBar\n          );\n        }\n\n        nextBeat += 1;\n        nextBeat %= beats;\n        // Set the next target to schedule for\n        nextNoteTime += secondsPerBeat;\n      }\n    } finally {\n      // TODO: Fallback to setTimeout if in background tab somehow... Otherwise I need\n      // to switch the audio loop to setTimeout and keep the UI on requestAnimationFrame (and\n      // take into account that multiple beats can be missed before the loop will resume)\n      frame = requestAnimationFrame(loop);\n    }\n  };\n\n  return (action) => {\n    // We need to track 2 versions of the state:\n    //\n    // 1. UI state (immediately updated on each user action)\n    // 2. Audio state (updated at the start of each quantization loop)\n\n    next(action);\n\n    // If the playing state has been toggled, start or stop the Raf loop\n    if (action.type === TOGGLE_PLAY && store.getState().grid.playing) {\n      const audioCtx = window.audioCtx || new AudioContext();\n      window.audioCtx = audioCtx;\n\n      nextBeat = 0;\n      nextGridBeat = 0;\n      nextNoteTime = audioCtx.currentTime + SCHEDULE_AHEAD_TIME;\n      nextGridChangeTime = audioCtx.currentTime + SCHEDULE_AHEAD_TIME;\n      frame = requestAnimationFrame(loop);\n    } else if (action.type === TOGGLE_PLAY && frame) {\n      window.gridElems.forEach((elem) => elem.classList.remove(\"active\"));\n      cancelAnimationFrame(frame);\n    }\n  };\n};\n\nexport default audioScheduler;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nimport { Provider } from 'react-redux'\nimport configureStore from './store'\n\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={configureStore()}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import { createStore, applyMiddleware } from \"redux\";\nimport rootReducer from \"./reducers/rootReducer\";\n\nimport audioScheduler from \"./middlewares/audioScheduler\";\n\nexport default function configureStore(initialState = {}) {\n  return createStore(rootReducer, initialState, applyMiddleware(audioScheduler));\n}\n"],"sourceRoot":""}